Name: Oscar Magana-Rivera
UGA ID: 811782259


Thread-pool & Synchronization:
	When main() is started, the main thread creates a thread, which runs the function req_handler(). In req_handler(), the listening socket accepts file descriptors (fd) in a while (1) loop, and places them into an array of integers, which is initialized to a size of MAX_REQUEST (100). After a fd is placed in the array, a thread is created and it runs the function producer() with a fd from the array as the argument for producer(). In producer(), the executing thread has an entry section in which an int variable, fd, is initialized using the argument passed to producer(). After the entry section, sem_wait() is called with the semaphore, sem_empty, to make sure that the shared buffer, request[], is not full. Then, the thread attempts to lock the mutex using pthread_mutex_trylock(), which is a non-blocking attempt to acquire the mutex. This aids in preventing deadlocks. After acquiring the mutex, the thread enters its critical section where the fd is placed into the shared buffer and two global variables, numRequest and nextProduced, which are of type int, are incremented by one. The variable numRequest is used to keep track of the number of active requests in the shared buffer, and nextProduced is used to keep track of which index of the shared buffer the next producer will place the next fd. After incrementing, the thread exits its critical section by unlocking the mutex and calling sem_post() with the semaphore, sem_full, to let consumer threads know that there is a request in the shared buffer to be consumed. Finally, the thread is terminated with a call to pthread_exit().

	After a thread is created to take care of producing, the main thread calls the function thread_control(). In thread_control(), N (numThread) threads are created, with each one executing the function consumer(). The thread id of each consumer thread is saved in an array. In consumer(), a thread immediately enters a while (1) loop and attempts to enter its critical section by calling sem_wait() with sem_full to make sure there is a request in the shared buffer before entering its critical section. Then, the thread attempts to lock the mutex using pthread_mutex_trylock(). After acquiring the mutex, the thread enters its critical section, where it consumes a fd from the shared buffer, decrements numRequest by one, and increments nextConsumed by one. The int variable, nextConsumed, keeps track of which index of the shared buffer the next consumer will read from. After incrementing, the thread exits its critical section by unlocking the mutex and calling sem_post() with sem_empty to notify a producer that there is space in the shared buffer for another request. Finally, in the remainder section of consumer(), the fd that was consumed is processed using process(), and the thread loops back to the beginning of the while (1) loop to do it all over again.


Crash handling & Testing:
      I implemented crash handling by saving the return value of a terminated thread in an int variable, retval, in net.c, where pthread_exit() is called to simulate crashing. The value of retval is made available to another consumer thread in thread_control(), where pthread_join() is called N (numThread) times in a for loop. In the same loop, The return value is compared to 0 (retval <= 0) in the condition statement of a while loop. If retval <= 0 evaluates to true (thread was terminated), then another consumer thread is created and joined in the same while loop. This code is from lines 69-71 of client.c.

      For testing, I placed various printf() statements in all functions other than main, and checked the last statement that was able to print whenever deadlocks occured. I assumed that there could not be race conditions since all shared data between the threads was only accessible after acquiring the mutex. Also, functions such as pthread_mutex_trylock() were used to aid in preventing deadlocks. Other than that, I ran the client program with 100 requests many times, all while changing the number of threads and crash rate each time the webserver program was rerun.