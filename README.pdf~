Name: Oscar Magana-Rivera
UGA ID: 811782259

Thread-pool & Synchronization:
	When main() is started, the main thread creates a thread, which runs the function req_handler(). In req_handler(), the listening socket accepts file descriptors (fd) in a while (1) loop, and places them into an array of integers, which is initialized to a size of MAX_REQUEST (100). After a fd is placed in the array, a thread is created and it runs the function producer() with a fd from the array as the argument for producer(). In producer(), the executing thread has an entry section in which an int variable, fd, is initialized using the argument passed to producer(). After the entry section, sem_wait() is called with the semaphore, sem_empty, to make sure that the shared buffer, request[], is not full. Then, the thread attempts to lock the mutex using pthread_mutex_trylock(), which is a non-blocking attempt to acquire the mutex. This aids in preventing deadlocks. After acquiring the mutex, the thread enters its critical section where the fd is placed into the shared buffer and two global variables, numRequest and nextProduced, which are of type int, are incremented by one. The variable numRequest is used to keep track of the number of active requests in the shared buffer, and nextProduced is used to keep track of which index of the shared buffer the next producer will place the next fd. After incrementing, the thread exits its critical section by unlocking the mutex and calling sem_post() with the semaphore, sem_full, to let consumer threads know that there is a request in the shared buffer to be consumed. Finally, thread is terminated with a call to pthread_exit().

	After a thread is created to take care of producing, the main thread calls the function thread_control(). In thread_control(), N (numThread) threads are created, with each one executing the function consumer(). The thread id of each consumer thread is saved in an array. In consumer(), a thread immediately attempts to enter its critical section by calling sem_wait() with sem_full to make sure there is a request in the shared buffer before entering its critical section. Then the thread attempts to lock the mutex using pthread_mutex_trylock(). After acquiring the mutex, the thread enters its critical section, . Then,   